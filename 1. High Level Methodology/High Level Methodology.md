## Table of Contents

* [Initial Enumeration](###Initial%20Enumeration)
* [OSINT](###OSINT)
* [Transport Layer](###Transport%20Layer)
* [Information Leakage](###Information%20Leakage)
* [Authentication](###Authentication)
* [Sessions](###Sessions)
* [Account Management](###Account%20Management)
* [Administration](###Administration)
* [Configuration](###Configuration)
* [Application tests](###Application%20tests)
* [File upload testing](###File%20upload%20testing)
* [DOM-based vulnerability testing](###DOM-based%20vulnerability%20testing)
* [Web Cache Poisoning](###Web%20Cache%20Poisoning)

### Initial Enumeration

- Nmap Scan
- SAST and DAST scan results (if available)
- Perform unauthenticated and authenticated (if possible) directory and file fuzzing with dirsearch and/or Burp Suite's Content Discovery (or dirb, ffuf, gobuster, etc.)
    - Search for exposed administrator/high level URLs or functionality
- Spider the site (Crawling with Burp Suite)
- Check for /robots.txt
- Check if different User-Agent strings expose new/different server response
- Identify technologies/frameworks/languages/database in use (Wappalyzer, HTTP headers)
- Identify user input points (send requests with interesting parameters to Burp's Repeater)
    - If allowed/server can handle it: use the Burp scanner to automate discovery of potential vulnerabilities. Use scan profiles [such as these](https://github.com/TheGetch/Burp-Suite-Pro-Scan-Profiles).
- Perform Subdomain Enumeration and Bruteforcing (if applicable)

**OSINT**

- Google dorks (`site:target_app.example.com filetype:pdf` etc.)
- Shodan
- Github
- Forums
- User Guides
- Default configurations
- Default credentials
- Known/disclosed vulnerabilities
- Patterns in disclosed vulnerabilities
- DNS
- Webservers (https://crt.sh/ is a fantastic resource)

### Transport Layer

- Encryption:
    - ensure secure ciphers are used, outdated SSL/TLS versions are not being used, check key lengths (sslscan/testssl.sh)
- Presence of the HTTP `Strict-Transport-Security` Header
- Check for redirection of all unencrypted traffic to encrypted
    - Ensure credentials and session cookies are not sent over HTTP

### Information Leakage

Look for:

- Software versions: Server/Framework/Language/Libraries
- Configuration Files
- Source code disclosures
- Log files
- Path disclosures
- Password Hashes
- Username disclosure
- Stack traces
- Internal IP addresses/Hostnames
- Emails
- PII
- Financial information

### Authentication

- Test default credentials (if applicable)
- Uses encrypted channels
- Does not distinguish between invalid usernames or invalid passwords (username enumeration) - Server responses remain the same
- Requires at least username/password (1FA)
- Supports two factor authentication (2FA) if required by compliance/company policy
    - Test that 2FA is not only supported but enforced (cannot be bypassed, brute-forced)
    - Test if the server response can be manipulated to bypass 2FA, i.e. `{"success":false}` to `{"success":true}` or changing HTTP status code, i.e. `403 Forbidden` to `200 OK`
    - Test null byte as 2FA code
    - Check if server leaks 2FA code in responses
- Accounts lock after a defined number of failed login attempts
    - Users are notified of account lockouts
- Password complexity is enforced to industry standard minimums
    - At least 8 characters in length
    - Must contain at least one digit
    - Must contain at least one special character
    - Cannot be the same as the username
    - Cannot be the same as the user's email
- Passwords are obscured when entering
- Passwords cannot be blank
- User identifiers are unique
- Test RBAC enforcement
    - Users cannot access other user data
    - Users cannot access admin functionality
    - Users cannot edit other user data
    - Users cannot brute-force data identifiers
- Test "Remember me" or "Keep me logged in" functionality
    - Ensure cookie is set with HTTPOnly flag
    - Ensure token or cookie cannot be brute-forced or guessed
- Check if `autocomplete="off"` is enabled within the FORM tag or within the INPUT tags. 
- Test the password reset and password recovery functionalities (if applicable)
    - Ensure password reset link and/or codes are unique/non-guessable
    - Check if reset link can be manipulated in a way to be used for another user
    - Check if security questions be brute-forced
    - Check if password links expire
    - Check that if more than one link is requested that the older links are invalidated 
- If authenticated, test the password change procedure
    - Check if the current active sessions get invalidated after password change (optional, but good practice)
- Test specially crafted usernames to overwrite default application pages, i.e. `/images/companylogo.jpg`
- Attempt to access resources while unauthenticated
    - Attempt to access administrative functionalities as a low-access-level user 

**Post Authentication**

- Check if user ID is used to retrieve data
    - Try other user IDs or brute force (IDOR)
- Document features and functionalities tied to different access-leveled accounts (applicable if you have multiple test accounts with differing access levels)
- Test features that change account information, i.e. email change, password change, phone number change, etc.
    - Test if these changes are vulnerable to CSRF

### Sessions

- Test that session tokens are secure (Use Burp's Sequencer for testing entropy of cookies set)
- Ensure tokens are not re-used (session fixation, CSRF token reuse, password reset token reuse, 2FA tokens)
- Check session expiration limit
- Session destruction:
    - Check if sessions are destroyed on the server, not just deleted in the browser. Resend requests in Burp with "logged-out" cookies to test if cookies are still accepted server-side. 
- Check if `secure`  flag is set on all session cookies (prevents the browser from sending cookies over unencrypted HTTP)
- Check if `HttpOnly`flag is set on all session cookies (prevents XSS attacks from accessing cookies)
- Ensure session data is stored server-side and not in the cookie (excludes ViewStates, JWTs - see next item)
- Ensure client-stored session information (i.e. ViewStates, JWTs) is cryptographically protected
    - If so, check if:
        - HMAC uses a strong secret (can attempt to brute force w/ hashcat)
        - Encrypted tokens use a strong algorithm/secret
- Sessions are invalidated after IP change (optional, but good practice for high security)
- Check if concurrent logins are allowed (optional if logins are supposed to be limited)

**JSON Web Tokens (JWT)**

- Ensure the token is signed using a secure algorithm 
- Try signing a modified token with the "none" algorithm 
- Change the signing algorithm, i.e. from `HS256` to `RS356`, etc.

### Account Management

- Users are notified on account updates
    - Email change (notification sent to both old and new)
    - Password change
- Passwords expire after defined period
    - Users are notified on password expiration
- Password resets do not reveal account information (i.e. usernames, emails, partially obscured emails, e.g. `te**********st@test.com`)
- Password changes require authentication
- Password changes require the old password
- 2FA changes require password
- Email change requires password
- Users cannot register a new account with the same name as an existing account
- Default accounts have had passwords changed

### Administration

- Administrative consoles are not exposed (varies by application/technology)
- Users are not administrators
- Authentication is required for administrative activities
- Unauthorized users cannot access administrative functions
- Application passwords are not exposed (i.e. connection strings)
- Significant security change requires reauthentication.

### Configuration

- No unnecessary services are exposed (like admin panels on 8080/8443, etc.)
- Firewalls are enabled and configured correctly
- Check if application components are up-to-date
- Check if directory indexing is not enabled
- Source code is not disclosed
- Source code backups do not exist (i.e. index.php~ or index.php.bak)
- Minimum permissions are used for system components (i.e. not using 'sa' or 'root' for database access, or running as 'root' for the application software)
- Load balancers do not expose internal IPs

### Application tests
- Check for robots.txt
    - No sensitive information is disclosed (such as /private, /logs etc.)
- Pages require authentication where necessary
- Pages honor POST vs GET requests (i.e. you cannot swap a GET to a POST)
- User controlled data is not used in a serialized fashion (i.e., user controlled data stored/sent in a deserialized Java object)
- Known formats are processed (i.e. Endpoints only accept `application/x-www-form-urlencoded` or `application/json`, and JSON endpoints do not accept XML)
- Test for HTTP Request Smuggling (use the Smuggle Probe that's part of the Burp Suite HTTP Request Smuggling extension)
- Test for HTTP verb tampering

**Cross Site Request Forgery (CSRF)**

- CSRF protections are implemented
- CSRF tokens are strictly validated in every case before the relevant action is executed.
- CSRF protections cannot be bypassed by removing the tokens
- CSRF protections cannot be bypassed by using invalid tokens
- CSRF protections cannot be bypassed using another user's valid token (must be tied to each user's session)
- CSRF protections are unpredictable with high entropy
- If you believe you have found a CSRF vulnerability, ensure all the following conditions are met (from [What is CSRF (Cross-site request forgery)? Tutorial & Examples | Web Security Academy)](https://portswigger.net/web-security/csrf):
    - A relevant action. There is an action within the application that the attacker has a reason to induce. This might be a privileged action (such as modifying permissions for other users) or any action on user-specific data (such as changing the user's own password).
    - Cookie-based session handling. Performing the action involves issuing one or more HTTP requests, and the application relies solely on session cookies to identify the user who has made the requests. There is no other mechanism in place for tracking sessions or validating user requests.
    - No unpredictable request parameters. The requests that perform the action do not contain any parameters whose values the attacker cannot determine or guess. For example, when causing a user to change their password, the function is not vulnerable if an attacker needs to know the value of the existing password.

**Server-Side Request Forgery (SSRF)**

- Common injection parameters:
    - `access=` 
    - `admin=` 
    - `dbg=` 
    - `debug=` 
    - `edit=` 
    - `grant=` 
    - `test=` 
    - `alter=` 
    - `clone=` 
    - `create=` 
    - `delete=` 
    - `disable=` 
    - `enable=` 
    - `exec=` 
    - `execute=` 
    - `load=` 
    - `make=` 
    - `modify=` 
    - `rename=` 
    - `reset=` 
    - `shell=` 
    - `toggle=` 
    - `adm=` 
    - `root=` 
    - `cfg=`
    - `dest=` 
    - `redirect=` 
    - `uri=` 
    - `path=` 
    - `continue=` 
    - `url=` 
    - `window=` 
    - `next=` 
    - `data=` 
    - `reference=` 
    - `site=` 
    - `html=` 
    - `val=` 
    - `validate=` 
    - `domain=` 
    - `callback=` 
    - `return=` 
    - `page=` 
    - `feed=` 
    - `host=` 
    - `port=` 
    - `to=` 
    - `out=`
    - `view=` 
    - `dir=` 
    - `show=` 
    - `navigation=` 
    - `open=`
    - `file=`
    - `document=`
    - `folder=`
    - `pg=`
    - `php_path=`
    - `style=`
    - `doc=`
    - `img=`
    - `filename=`
- Test SSRF within open redirects (if open redirects were found)
- Try localhost/127.0.0.1 payloads or other internal IPs (if known)
    - Use alternative IP representation of `127.0.0.1`, such as `2130706433`, `017700000001`, or `127.1`.
    - Register your own domain name that resolves to `127.0.0.1`. You can use `spoofed.burpcollaborator.net` for this purpose.
    - Obfuscate blocked strings using URL encoding or case variation.
- For out-of-band testing use Burp Collaborator 
    - Use Burp extension “Collaborator Everywhere” for automatic header injection (use with caution - if you have trouble connecting to application, disable this first to see if causing any issues)
- Injection SSRF payload into `Referer` header

**Parameter testing:**

- Test for unkeyed and/or hidden parameters (use Param Miner)
- Test if there are any responses changes when POST parameters are included in GETs and vice versa. 
- Test each query parameter (where possible) for SQLi
    - See [PayloadsAllTheThings - SQL Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection) for examples.
    - See [SecLists - SQLi](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/SQLi) for examples
    - [Bypassing common filters](https://portswigger.net/support/sql-injection-bypassing-common-filters):
        - Inject Null byte (`%00`) before SQL payload
        - Use SQL inline comment sequence, i.e. `0/**/or/**/1`
        - URL encode the payload
        - Change case (upper/lowercase, i.e. `uNIon SelEct`)
        - [Use sqlmap tamper scripts](https://medium.com/@drag0n/sqlmap-tamper-scripts-sql-injection-and-waf-bypass-c5a3f5764cb3)
- Test each query parameter (where possible) for NoSQLi
    - See [PayloadsAllTheThings - NoSQL Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection) for examples.
- Test each query parameter (where possible) for XSS (Stored, Reflected, DOM)
    - See [PayloadsAllTheThings - XSS Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection) for examples.
    - See [PortSwigger’s XSS cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)
    - See [SecLists - XSS](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/XSS) for examples
    - Test file uploads to XSS (svg filetypes)
    - If some tags are blacklisted, use Burp Intruder to determine allowed HTML tags
    - Change GET requests to POST requests and vice versa. Might bypass parameter filtering
    -  Change case (upper/lowercase, i.e. `sCritP`)
    - Encode characters, i.e. `s%63ript`
- Test each query parameter (where possible) for Command Injection
    - See [PayloadsAllTheThings - Command Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection) for examples.
    - See [SecLists - Command Injection](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/command-injection-commix.txt) for examples.
- Test each query parameter (where possible) for HPP (HTTP Parameter Pollution)
    - See [PayloadsAllTheThings - HTTP Parameter Pollution](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/HTTP%20Parameter%20Pollution) for examples.
- Test each query parameter (where possible) for Null byte injection (all variants)
- Test each query parameter (where possible) for Path manipulation
- Test each query parameter (where possible) for directory traversal
    - See [PayloadsAllTheThings - Directory Traversal](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Directory%20Traversal) for examples.
    - Try different encodings: 
        - `%2e%2e%2f`
        - `%252e%252e%252f`
        - `..%c0%af`
        - `..%ef%bc%8f`
    - Or nested traversal sequences:
        - `....//`
        - `....\/`
- Test each query parameter (where possible) for XML/XXE attacks
    - See [PayloadsAllTheThings - XXE Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20Injection) for examples.
    - See [SecLists - XML](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/XML-FUZZ.txt) for examples.
    - See [SecLists - XXE](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/XXE-Fuzzing.txt) for examples.
- Test each query parameter (where possible) for Type errors (converting to arrays, vs integers, vs strings)
    - See [PayloadsAllTheThings - Type Juggling](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Type%20Juggling) for examples.
- Test each query parameter (where possible) for SSI (Server Side Includes)
    - See [SecLists - SSI](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/SSI-Injection-Jhaddix.txt) for examples.
- Test each query parameter (where possible) for SSTI (Server Side Template Injection)
    - See [PayloadsAllTheThings - Server Side Template Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection) for examples.
    - See [SecLists - template-engines-expression](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/template-engines-expression.txt) for examples
    - See [SecLists - template-engines-special-vars](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/template-engines-special-vars.txt) for examples
- Test each query parameter (where possible) for open redirects. Common injection parameters:
    - `/{payload}`
    - `?next={payload}`
    - `?url={payload}`
    - `?target={payload}`
    - `?rurl={payload}`
    - `?dest={payload}`
    - `?destination={payload}`
    - `?redir={payload}`
    - `?redirect_uri={payload}`
    - `?redirect_url={payload}`
    - `?redirect={payload}`
    - `/redirect/{payload}`
    - `/cgi-bin/redirect.cgi?{payload}`
    - `/out/{payload}`
    - `/out?{payload}`
    - `?view={payload}`
    - `/login?to={payload}`
    - `?image_url={payload}`
    - `?go={payload}`
    - `?return={payload}`
    - `?returnTo={payload}`
    - `?return_to={payload}`
    - `?checkout_url={payload}`
    - `?continue={payload}`
    - `?return_path={payload} `
    - See [PayloadsAllTheThings - Open Redirect](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Open%20Redirect) for examples.
- Test each query parameter (where possible) for LFI and RFI
    - See [PayloadsAllTheThings - File Inclusion](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion) for examples.
    - See [SecLists - LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI) for examples
- Check if Web Sockets are being used and attempt injections into user-supplied input
    - See [PayloadsAllTheThings - Web Sockets](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Web%20Sockets) for examples.

**Header testing:**

- Check Content Security Policy (CSP) implementation 
    - No insecure directives (unsafe-inline, unsafe-eval)
- Check for HTTP security headers (X-XSS-Protection, X-Frame-Options, CSP, HSTS)
- Test for unkeyed and/or hidden headers (use Param Miner)
- Supply an arbitrary Host header
- Check for flawed validation (i.e. `Host: vulnerable-website.com:bad-stuff-here` or `Host: hacked-subdomain.vulnerable-website.com`)
- Inject duplicate `Host` headers
- Supply an absolute URL, i.e. `GET https://vulnerable-website.com/ HTTP/1.1 Host: bad-stuff-here`
- Add line wrapping, i.e.:
```http
GET /example HTTP/1.1
    Host: bad-stuff-here
Host: vulnerable-website.com
```
- Inject host override headers, i.e. -   `X-Host`, `X-Forwarded-Server`, `X-HTTP-Host-Override`, `Forwarded`
- Check for SQLi within request headers
- Test CORS implementation:
    - Inject an `Origin` request header and see if it is reflected in the `Access-Control-Allow-Origin` response header
    - Test for Origin header parsing errors, i.e. `victim.com.evil.com` may be allowed
    - Send a request with Origin header set to `null`

### File upload testing:

- See [PayloadsAllTheThings - Upload Insecure Files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files) for more examples.
- Test for unrestricted file uploads
    - If any file type allowed, attempt web shell upload
- Test for file type validation 
    - Change Content-Type header within the form-data of the request
- Test for path traversal within the filename of the uploaded file
    - Encoding for `../` might be required, i.e. `..%2f`
- If file blacklisting is observed, attempt bypasses, i.e. if `.php` is blacklisted, try `.php5`. Use Burp Intruder and the file extension payloads to fuzz for blacklisted extensions. 
- Attempt to upload a malicious `.htaccess` or `web.config` file.
    - For example, for apache, you can upload a fake .htaccess file containing:

```
 LoadModule php_module usr/lib/apache2/modules/libphp.so  
AddType application/x-httpd-php .php5
```

- For IIS you can upload a `web.config`:

```
<staticContent>  
  <mimeMap fileExtension=".php5" mimeType="application/x-httpd-php" />  
</staticContent>`
```

- Test for file extension obfuscation. From [Portswigger](https://portswigger.net/web-security/file-upload):
    - Provide multiple extensions. Depending on the algorithm used to parse the filename, the following file may be interpreted as either a PHP file or JPG image: `exploit.php.jpg`
    - Add trailing characters. Some components will strip or ignore trailing whitespaces, dots, and suchlike: `exploit.php.`
    - Try using the URL encoding (or double URL encoding) for dots, forward slashes, and backward slashes. If the value isn't decoded when validating the file extension, but is later decoded server-side, this can also allow you to upload malicious files that would otherwise be blocked: `exploit%2Ephp`
    - Add semicolons or URL-encoded null byte characters before the file extension. If validation is written in a high-level language like PHP or Java, but the server processes the file using lower-level functions in C/C++, for example, this can cause discrepancies in what is treated as the end of the filename: `exploit.asp;.jpg` or `exploit.asp%00.jpg`
    - Try using multibyte unicode characters, which may be converted to null bytes and dots after unicode conversion or normalization. Sequences like `xC0 x2E`, `xC4 xAE` or `xC0 xAE` may be translated to `x2E` if the filename parsed as a UTF-8 string, but then converted to ASCII characters before being used in a path.
- Try including malicious code within image metadata
- Test if files can be uploaded with PUT
- If file parsing is being performed on uploaded files, such as xml parsing, try including XXE payloads
- Test if AntiVirus scanning is performed on uploads
    - Can use the [EICAR](https://github.com/danielmiessler/SecLists/blob/master/Payloads/Anti-Virus/eicar-com.txt) AV test file 

### DOM-based vulnerability testing:

- Use DOM Invader (within Burp’s integrated browser)
- Search JavaScript code for common sources:
    - `document.URL`
    - `document.documentURI`
    - `document.URLUnencoded`
    - `document.baseURI`
    - `location`
    - `document.cookie`
    - `document.referrer`
    - `window.name`
    - `history.pushState`
    - `history.replaceState`
    - `localStorage`
    - `sessionStorage`
    - `IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)`
    - `Database`
- Search for sinks that can lead to DOM vulnerabilities (from [Portswigger](https://portswigger.net/web-security/dom-based)):

|DOM-based vulnerability|Example sink|
|-|-|
|DOM XSS|`document.write()`|
|Open redirection|`window.location`|
|Cookie manipulation |`document.cookie`|
|JavaScript injection|`eval()`|
|Document-domain manipulation|`document.domain`|
|WebSocket-URL poisoning|`WebSocket()`|
|Link manipulation|`element.src`|
|Web message manipulation|`postMessage()`|
|Ajax request-header manipulation|`setRequestHeader()`|
|Local file-path manipulation|`FileReader.readAsText()`|
|Client-side SQL injection|`ExecuteSql()`|
|HTML5-storage manipulation|`sessionStorage.setItem()`|
|Client-side XPath injection|`document.evaluate()`|
|Client-side JSON injection|`JSON.parse()`|
|DOM-data manipulation|`element.setAttribute()`|
|Denial of service|`RegExp()`|


### Web Cache Poisoning

- Use Param Miner Burp Suite extension to identify unkeyed inputs
- Check for unkeyed port
    - Could cause temporary denial-of-service if arbitrary port is cached
- Attempt XSS within a poisoned cache
    - Use an unkeyed input that is reflected, i.e. `X-Forwarded-Host: a."><script>alert(1)</script>"`
- Check if URLs are dynamically generated within responses based off unkeyed headers, i.e.  `X-Host`, `X-Forwarded-Host`, etc.
- Check if response content is dynamically generated from cookies
- If Akamai-based, use `Pragma: akamai-x-get-cache-key` header in request to potentially display the cache key in response headers
- Check for unkeyed UTM query parameters, i.e. `utm_content`
- Cloak arbitrary parameters, i.e. `GET /?example=123?excluded_param=bad-stuff-here`
- Test "fat" GET requests, i.e.:
```http
GET /?param=innocent HTTP/1.1
…
param=bad-stuff-here
```

---

References:
- https://github.com/tanprathan/OWASP-Testing-Checklist
- https://portswigger.net/web-security
- https://www.appsecmonkey.com/blog/web-application-security-checklist
- https://github.com/riramar/Web-Attack-Cheat-Sheet
- https://alike-lantern-72d.notion.site/Web-Application-Penetration-Testing-Checklist-4792d95add7d4ffd85dd50a5f50659c6
