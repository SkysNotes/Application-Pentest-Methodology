## Table of Contents

* [Transport Layer](###Transport%20Layer)
* [Initial Enumeration](###Initial%20Enumeration)
* [Information Leakage](###Information%20Leakage)
* [Sessions](###Sessions)
* [Authentication](###Authentication)
* [Account Management](###Account%20Management)
* [Administration](###Administration)
* [Configuration](###Configuration)
* [Application](###Application)
* [Application tests](###Application%20tests)
* [File upload testing](###File%20upload%20testing)
* [CORS testing](###CORS%20testing)
* [WebSockets testing](###WebSockets%20testing)
* [DOM-based vulnerability testing](###DOM-based%20vulnerability%20testing)
* [Web Cache Poisoning](###Web%20Cache%20Poisoning)
* [OSINT](###OSINT)

### Initial Enumeration

- Nmap Scan
- Perform unauthenticated and authenticated (if possible) directory and file fuzzing with dirsearch and/or Burp Suite's Content Discovery (or dirb, ffuf, gobuster, etc.)
    - Search for exposed administrator/high level URLs or functionality
- Spider the site (Crawling with Burp Suite)
- Check for /robots.txt
- Check if different User-Agent strings expose new/different server response
- Identify technologies/frameworks/languages in use (Wappalyzer, HTTP headers)
- Identify user input points (send requests with interesting parameters to Burp's Repeater)

### Transport Layer

- Encryption:
    - ensure secure ciphers are used, outdated SSL/TLS versions are not being used, check key lengths (sslscan/testssl.sh)
- Presence of the HTTP `Strict-Transport-Security` Header
- Check for redirection of all unencrypted traffic to encrypted
    - Ensure credentials and session cookies are not sent over HTTP

### Information Leakage

Look for:

- Software versions: Server/Framework/Language/Libraries
- Configuration Files
- Source code disclosures
- Log files
- Path disclosures
- Password Hashes
- Username disclosure
- Stack traces
- Internal IP addresses/Hostnames
- Emails
- PII
- Financial information

### Sessions

- Test that session tokens are secure (Use Burp's Sequencer for testing entropy of cookies set)
- Ensure tokens are not re-used (session fixation, CSRF token reuse, password reset token reuse, 2FA tokens)
- Check session expiration limit
- Session destruction:
    - Check if sessions are destroyed on the server, not just deleted in the browser. Resend requests in Burp with "logged-out" cookies to test if cookies are still accepted server-side. 
- Check if `secure`  flag is set on all session cookies (prevents the browser from sending cookies over unencrypted HTTP)
- Check if `HttpOnly`flag is set on all session cookies (prevents XSS attacks from accessing cookies)
- Ensure session data is stored server-side and not in the cookie (excludes ViewStates, JWTs - see next item)
- Ensure client-stored session information (i.e. ViewStates, JWTs) is cryptographically protected
    - If so, check if:
        - HMAC uses a strong secret (can attempt to brute force w/ hashcat)
        - Encrypted tokens use a strong algorithm/secret
- Sessions are invalidated after IP change (optional, but good practice for high security)

### Authentication

- Test default credentials (if applicable)
- Uses encrypted channels
- Does not distinguish between invalid usernames or invalid passwords (info disclosure) - Server responses remain the same
- Requires at least username/password (1FA)
- Supports two factor authentication (2FA) if required by compliance/company policy
    - Test that 2FA is not only supported but enforced (cannot be bypassed, brute-forced)
- Accounts lock after a defined number of failed login attempts
    - Users are notified of account lockouts
- Password complexity is enforced to industry standard minimums
    - At least 8 characters in length
    - Must contain at least one digit
    - Must contain at least one special character
    - Cannot be the same as the username
    - Cannot be the same as the user's email
- Passwords are obscured when entering
- Passwords cannot be blank
- User identifiers are unique
- Test RBAC enforcement
    - Users cannot access other user data
    - Users cannot access admin functionality
    - Users cannot edit other user data
    - Users cannot brute-force data identifiers
- Test "Remember me" or "Keep me logged in" functionality
    - Ensure cookie is set with HTTPOnly flag
    - Ensure token or cookie cannot be brute-forced or guessed
- Check if `autocomplete="off"` is enabled within the FORM tag or within the INPUT tags. 
- Test the password reset and password recovery functionalities (if applicable)
- If authenticated, test the password change procedure

### Account Management

- Users are notified on account updates
    - Email change (notification sent to both old and new)
    - Password change
- Passwords expire after defined period
    - Users are notified on password expiration
- Password resets do not reveal account information (i.e. usernames, emails, partially obscured emails, e.g. `te**********st@test.com`)
- Password changes require authentication
- Password changes require the old password
- Users cannot register a new account with the same name as an existing account
- Default accounts have had passwords changed

### Administration

- Administrative consoles are not exposed (varies by application/technology)
- Users are not administrators
- Authentication is required for administrative activities
- Unauthorized users cannot access administrative functions
- Application passwords are not exposed (i.e. connection strings)

### Configuration

- No unnecessary services are exposed (like admin panels on 8080/8443, etc.)
- Firewalls are enabled and configured correctly
- Check if application components are up-to-date
- Check if directory indexing is not enabled
- Source code is not disclosed
- Source code backups do not exist (i.e. index.php~ or index.php.bak)
- Minimum permissions are used for system components (i.e. not using 'sa' or 'root' for database access, or running as 'root' for the application software)
- Load balancers do not expose internal IPs

### Application

- Cross Site Request Forgery
    - CSRF protections are implemented
    - CSRF tokens are strictly validated in every case before the relevant action is executed.
    - CSRF protections cannot be bypassed by removing the tokens
    - CSRF protections cannot be bypassed by using invalid tokens
    - CSRF protections cannot be bypassed using another user's valid token (must be tied to each user's session)
    - CSRF protections are unpredictable with high entropy
- robots.txt
    - No sensitive information is disclosed (such as /private, /logs etc.)
- Pages require authentication where necessary
- Pages honor POST vs GET requests (i.e. you cannot swap a GET to a POST)
- User controlled data is not used in a serialized fashion (i.e., user controlled data stored/sent in a deserialized Java object)
- Known formats are processed (i.e. Endpoints only accept `application/x-www-form-urlencoded` or `application/json`, and JSON endpoints do not accept XML)
- Test for HTTP Request Smuggling (use the Smuggle Probe that's part of the Burp Suite HTTP Request Smuggling extension)
- Test for HTTP verb tampering

### Application tests

**Parameter testing:**

- Test for unkeyed and/or hidden parameters (use Param Miner)
- Test if there are any responses changes when POST parameters are included in GETs and vice versa. 
- Test each query parameter (where possible) for SQLi
- Test each query parameter (where possible) for NoSQLi
- Test each query parameter (where possible) for XSS (Stored, Reflected, DOM)
- Test each query parameter (where possible) for Command Injection
- Test each query parameter (where possible) for HPP (HTTP Parameter Pollution)
- Test each query parameter (where possible) for Null byte injection (all variants)
- Test each query parameter (where possible) for Path manipulation
- Test each query parameter (where possible) for directory traversal
    - Try different encodings: 
        - `%2e%2e%2f`
        - `%252e%252e%252f`
        - `..%c0%af`
        - `..%ef%bc%8f`
    - Or nested traversal sequences:
        - `....//`
        - `....\/`
- Test each query parameter (where possible) for XML/XXE attacks
- Test each query parameter (where possible) for Type errors (converting to arrays, vs integers, vs strings)
- Test each query parameter (where possible) for SSI (Server Side Includes)
- Test each query parameter (where possible) for SSTI (Server Side Template Injection)
- Test each query parameter (where possible) for open redirects
- Test each query parameter (where possible) for LFI and RFI
- Check if Web Sockets are being used and attempt injections into user-supplied input

**Header testing:**

- Check Content Security Policy (CSP) implementation 
    - No insecure directives (unsafe-inline, unsafe-eval)
- Check for HTTP security headers (X-XSS-Protection, X-Frame-Options, CSP, HSTS)
- Test for unkeyed and/or hidden headers (use Param Miner)
- Supply an arbitrary Host header
- Check for flawed validation (i.e. `Host: vulnerable-website.com:bad-stuff-here` or `Host: hacked-subdomain.vulnerable-website.com`)
- Inject duplicate Host headers
- Supply an absolute URL, i.e. `GET https://vulnerable-website.com/ HTTP/1.1 Host: bad-stuff-here`
- Add line wrapping, i.e.:
```http
GET /example HTTP/1.1
    Host: bad-stuff-here
Host: vulnerable-website.com
```
- Inject host override headers, i.e. -   `X-Host`, `X-Forwarded-Server`, `X-HTTP-Host-Override`, `Forwarded`
- Check for SQLi within request headers
- Test CORS implementation:
    - Inject an `Origin` request header and see if it is reflected in the `Access-Control-Allow-Origin` response header
    - Test for Origin header parsing errors, i.e. `victim.com.evil.com` may be allowed
    - Send a request with Origin header set to `null`

### File upload testing:

- Test for unrestricted file uploads
    - If any file type allowed, attempt web shell upload
- Test for file type validation 
    - Change Content-Type header within the form-data of the request
- Test for path traversal within the filename of the uploaded file
    - Encoding for `../` might be required, i.e. `..%2f`
- If file blacklisting is observed, attempt bypasses, i.e. if `.php` is blacklisted, try `.php5`. Use Burp Intruder and the file extension payloads to fuzz for blacklisted extensions. 
- Attempt to upload a malicious `.htaccess` or `web.config` file.
    - For example, for apache, you can upload a fake .htaccess file containing:

```
 LoadModule php_module usr/lib/apache2/modules/libphp.so  
AddType application/x-httpd-php .php5
```

- For IIS you can upload a `web.config`:

```
<staticContent>  
  <mimeMap fileExtension=".php5" mimeType="application/x-httpd-php" />  
</staticContent>`
```

- Test for file extension obfuscation. From [Portswigger](https://portswigger.net/web-security/file-upload):
    - Provide multiple extensions. Depending on the algorithm used to parse the filename, the following file may be interpreted as either a PHP file or JPG image: `exploit.php.jpg`
    - Add trailing characters. Some components will strip or ignore trailing whitespaces, dots, and suchlike: `exploit.php.`
    - Try using the URL encoding (or double URL encoding) for dots, forward slashes, and backward slashes. If the value isn't decoded when validating the file extension, but is later decoded server-side, this can also allow you to upload malicious files that would otherwise be blocked: `exploit%2Ephp`
    - Add semicolons or URL-encoded null byte characters before the file extension. If validation is written in a high-level language like PHP or Java, but the server processes the file using lower-level functions in C/C++, for example, this can cause discrepancies in what is treated as the end of the filename: `exploit.asp;.jpg` or `exploit.asp%00.jpg`
    - Try using multibyte unicode characters, which may be converted to null bytes and dots after unicode conversion or normalization. Sequences like `xC0 x2E`, `xC4 xAE` or `xC0 xAE` may be translated to `x2E` if the filename parsed as a UTF-8 string, but then converted to ASCII characters before being used in a path.
- Try including malicious code within image metadata
- Test if files can be uploaded with PUT
- If file parsing is being performed on uploaded files, such as xml parsing, try including XXE payloads
- Test if AntiVirus scanning is performed on uploads
    - Can use the [EICAR](https://github.com/danielmiessler/SecLists/blob/master/Payloads/Anti-Virus/eicar-com.txt) AV test file 

### DOM-based vulnerability testing:

- Search JavaScript code for common sources:
    - `document.URL`
    - `document.documentURI`
    - `document.URLUnencoded`
    - `document.baseURI`
    - `location`
    - `document.cookie`
    - `document.referrer`
    - `window.name`
    - `history.pushState`
    - `history.replaceState`
    - `localStorage`
    - `sessionStorage`
    - `IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)`
    - `Database`
- Search for sinks that can lead to DOM vulnerabilities (from [Portswigger](https://portswigger.net/web-security/dom-based)):

|DOM-based vulnerability|Example sink|
|-|-|
|DOM XSS|`document.write()`|
|Open redirection|`window.location`|
|Cookie manipulation |`document.cookie`|
|JavaScript injection|`eval()`|
|Document-domain manipulation|`document.domain`|
|WebSocket-URL poisoning|`WebSocket()`|
|Link manipulation|`element.src`|
|Web message manipulation|`postMessage()`|
|Ajax request-header manipulation|`setRequestHeader()`|
|Local file-path manipulation|`FileReader.readAsText()`|
|Client-side SQL injection|`ExecuteSql()`|
|HTML5-storage manipulation|`sessionStorage.setItem()`|
|Client-side XPath injection|`document.evaluate()`|
|Client-side JSON injection|`JSON.parse()`|
|DOM-data manipulation|`element.setAttribute()`|
|Denial of service|`RegExp()`|


### Web Cache Poisoning

- Use Param Miner Burp Suite extension to identify unkeyed inputs
- Check for unkeyed port
    - Could cause temporary denial-of-service if arbitrary port is cached
- Attempt XSS within a poisoned cache
    - Use an unkeyed input that is reflected, i.e. `X-Forwarded-Host: a."><script>alert(1)</script>"`
- Check if URLs are dynamically generated within responses based off unkeyed headers, i.e.  `X-Host`, `X-Forwarded-Host`, etc.
- Check if response content is dynamically generated from cookies
- If Akamai-based, use `Pragma: akamai-x-get-cache-key` header in request to potentially display the cache key in response headers
- Check for unkeyed UTM query parameters, i.e. `utm_content`
- Cloak arbitrary parameters, i.e. `GET /?example=123?excluded_param=bad-stuff-here`
- Test "fat" GET requests, i.e.:
```http
GET /?param=innocent HTTP/1.1
…
param=bad-stuff-here
```

### OSINT

- Google dorks (`site:target_app.example.com filetype:pdf` etc.)
- Shodan
- Github
- Forums
- User Guides
- Default configurations
- Default credentials
- Known vulnerabilities
- Patterns in disclosed vulnerabilities
- DNS
- Webservers (https://crt.sh/ is a fantastic resource)